# Modified for extra large (1000+ nodes) clusters by:
# Nexenta Systems, Inc 2014
 
# In Corosync, this option can be set to define a compatibility level to run at.
# Currently, the only two values are 'whitetank' and 'none'. The default is
# 'whitetank', which tells corosync to run compatible with OpenAIS 0.80.x. This
# will slow things down a bit, as such for CCOW we set it to none.
compatibility: none
 
# Totem Protocol options.
totem {
	version: 2

	# CCOW operates with IPv6 only for private rings
	ip_version: ipv6
 
	# When set to 'on', data will be encrypted using sober128 and that
	# HMAC/SHA1 is used for authentication. This adds a 36 byes header to
	# all totem messages. When enabled, this accounts for 75% of the CPU
	# usage used by the aisexec. Further, it will substantially increase
	# the CPU requirements of your nodes and will reduce transfer speeds
	# a non-trivial amount. For this reason, only enable this when you
	# are using an unsecure network and be sure to test to see how much
	# overhead it encures so that you can increase hardware resources if
	# needed. Please see 'man corosync.conf' for two specific examples of
	# performance trade-offs seen when enabling this. The default is 'on'.
	secauth: off
 
	# When 'secauth' is 'off', this variable is ignored. When 'secauth' is
	# 'on', this defined how many threads may be used for encypting and
	# sending multicast messages. A value of '0' disabled multiple threads.
	# This is most useful on non-SMP machines.
	threads: 4
 
	# This is a 32-bit value identifying this node when joining the CLM.
	# When using IPv4 addresses, this is an optional argument. When not
	# specified, the 'bindnetaddr' IP address specified in the 'interface'
	# directive with the 'ringnumber' '0' is used to generate this value.
	# However, if the IP address is IPv6, this mechanism can not be used
	# and you must manually specify a 'nodeid'. A 'nodeid' of '0' is
	# reserved and must not be used.
	nodeid: 11
 
	# This defined the size of the maximum transfer unit in bytes. The
	# default is 1500. If you want to use jumbo frames, frames larger than
	# 1500, *all* devices in your network *must* also support jumbo frames
	# and all hosts must also have their MTU set to the same size defined
	# below.
	# NOTE 1: Some hardware that claims to support jumbo frames (aka: large
	# frames) are actually limited to a max of 4500 or 9000 bytes. If you
	# find the network frequently reconfigures when using multicast, you
	# probably have hardware that isn't supporting your frame size.
	# NOTE 2; Linux adds 18 bytes to the packets generated by totem, so if
	# you are having trouble, drop the size of your frames to n-18. For
	# example, if you want to use 9000, set this to 8982.
	# NOTE 3: The man page describes a scenario where increasing the frame
	# size to 9000 (8982) increased throughput from 30MB/s to 60MB/s.
	netmtu: 8982
 
	# This defines what Virtual Synchrony Filter type is used to identify a
	# primary component. The prefered and default option is 'ykd' dynamic
	# linear voting. This consumes a lot of memory on clusters larger than
	# 32 nodes though. If you want to use more than 32 nodes, please see
	# the man page for details. If you set this to 'none', then AMF 
	# (Availability Management Framework) and DLCK (Distributed LoCKing)
	# are not safe to use. Leave this as 'ykd' unless you are sure you need
	# to change it.
	# Valid options; ykd, none
	vsftype: none
 
	# This is the number of milliseconds that totem will wait before
	# declaring a token to be lost. Once a token loss is declared, the
	# configuration will be reformed, which usually takes an additional
	# 50 milliseconds. The default is 1000 (1 second).
	token: 2000
 
	# This is the number of times that a token will be retransmitted before
	# a new configuration is formed. When set, 'token_retransmit' and
	# 'hold' will automatically be calculated using this and the 'token'
	# value. The default is '4'.
	retransmits_before_loss: 15
 
	# This tells corosync how long to wait, in milliseconds, for join
	# messages in the membership protocol. The default is '50'.
	join: 1000
 
	# This variable is a type of flood control that tells a node how long
	# to wait before sending a join message. Specifically, a node will wait
	# between '0' and this value before sending to help prevent flooding
	# the network with join messages on large rings. With clusters under 32
	# nodes, leave this set to it's default of '0'. With 128 nodes ore more,
	# a value of '80' milliseconds is sane.
	send_join: 100
 
	# This is the timeout in milliseconds that corosync will wait for
	# consensus to be achieved before starting a new round of membership
	# configuration. The default is '200'.
	consensus: 1500
 
	# This is the amount of time, in milliseconds, that corosync will wait
	# before checking if an interface is back up after it has gone down.
	# The default is '1000'.
	downcheck: 2000
 
	# When multicast traffic stops, this tells corosync how long, in
	# milliseconds, to wait before checking for a partition. The default is
	# '200'.
	merge: 400
 
	# This constant sets the number of messages that a given node may send
	# on one pass of the token. If all nodes perform equally well, this can
	# be set to a high number, like 300. However, if your cluster has a
	# large number of nodes, this could induce latency. If you have 16 or
	# more nodes, you should set this to the default of '50'. If, however,
	# one or more nodes are slower than the rest, this should be set to no
	# more than 256000/netmtu (ie: 256000/9000 = 28.4, so '25' is good).
	# This will avoid overflowing the kernel's transmit buffers. Should
	# this happen, there will be retransmit notices in the notification log
	# file and performance will suffer.
	window_size: 300
 
	# This constant sets the maximum number of messages that may be sent by
	# node on receipt of the of the token. This is limited to 256000/netmtu
	# (ie: 256000/9000 = 28.4, so '25' is good). This is to prevent
	# overflowing the kernel's transmit buffers. The default is 17.
	max_messages: 25

	# This specifies the mode of redundant ring, which may be none, active,
	# or passive. Active replication offers slightly lower latency from
	# transmit to delivery in faulty network environments but with less
	# performance.  Passive replication may nearly double the speed of the
	# totem protocol if the protocol doesn't become CPU bound. The final
	# option is none, in which case only one network interface will be
	# used to operate the totem protocol.


#	interface {
#		ringnumber:  1
#		bindnetaddr: fe80::a2
#		mcastaddr: ff02::c:0:0:2
#		mcastport: 10383
#		ttl: 3
#	}
	rrp_mode: none
	interface {
		ringnumber:  0
		bindnetaddr: eth0
		mcastaddr: ff02::c:0:0:1
		mcastport: 10381
		ttl: 4
	}
}
 
# This directive controls how Corosync logs it's messages. All variables here
# are optional.
logging {
	# Setting this to 'on' will replace the logger name in the log entries
	# with the file and line generating the log entry. The default is
	# 'off'.
	fileline: off
 
	# This controls whether a timestamp is recorded in the log files.
	# Valid options are 'off' and 'on', with 'off' being the default.
	timestamp: on
 
	# This control whether the function name generating the log entry is
	# recorded or not. Valid options are 'off' and 'on', with 'off' being
	# the default.
	function_name: off
 
	# These three options control where log messages are sent. Logs can be
	# sent to two or all three. The three options are: 'to_logfile',
	# 'to_syslog' and 'to_stderr'. All three can either be 'yes' or 'no'.
	# When set to 'yes', logs are sent to the relative destination. The
	# default is to write to the syslog and to stderr.
 
	# This directs output to a file. If set to 'yes', you must set a
	# 'logfile' argument below. Default is 'no'.
	to_logfile: yes
 
	# Default is 'yes'.
	to_syslog: no
 
	# Default is 'yes'.
	to_stderr: no
 
	# When 'to_logfile: yes' is set, this is required. It is the full path
	# and file name to write the logs to.
	logfile: /opt/nedge/var/log/cluster/corosync.log
 
	# Setting this to 'on', the default, generates a lot of debug messages
	# in the log. It is generally not advised unless you are tracing a
	# specific bug.
	debug: off
 
	# When writing to syslog, this sets the syslog facility to use. Valid
	# options are:
	# daemon, local0, local1, local2, local3, local4, local5, local6 and
	# local7
	# The default is 'daemon'.
	#syslog_facility: daemon
 
	# This is an optional directive that controls detailed logging
	# features. Generally, this is only needed by developers.
	logger_subsys {
		# This specifies the identity logging being specified.
		subsys: QUORUM
 
		# This enables or disables debug log messages for the component
		# identified above. The default is 'off'.
		debug: off
 
		# This specifies which tags should be logged for this
		# component. This is only valid when debug is enabled above.
		# Multiple tags are specified with a pipe (|) as the logical
		# OR seperator. The default is 'none'.
		#tags: enter|return|trace1|trace2
	}
}

quorum {
	# Enable and configure quorum subsystem (default: off)
	# see also corosync.conf.5 and votequorum.5
	provider: corosync_votequorum
	expected_votes: 1
	wait_for_all: 1
}
 
# This must exist and be set to disabled if you have openais installed. It's
# safe to include it regardless. AMF is not currently supported.
amf {
        mode: disabled
}
